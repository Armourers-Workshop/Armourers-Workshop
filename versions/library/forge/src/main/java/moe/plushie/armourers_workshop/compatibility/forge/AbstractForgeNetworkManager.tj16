package moe.plushie.armourers_workshop.compatibility.forge;

import moe.plushie.armourers_workshop.api.annotation.Available;
import moe.plushie.armourers_workshop.init.ModConfig;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.network.protocol.Packet;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.entity.Entity;
import net.minecraftforge.fml.network.ICustomPacket;
import net.minecraftforge.fml.network.NetworkDirection;
import net.minecraftforge.fml.network.NetworkEvent;
import net.minecraftforge.fml.network.NetworkRegistry;
import net.minecraftforge.fml.network.PacketDistributor;
import net.minecraftforge.fml.network.event.EventNetworkChannel;
import org.apache.commons.lang3.tuple.Pair;

import java.util.function.Supplier;

@Available("[1.16, 1.18)")
public abstract class AbstractForgeNetworkManager extends NetworkEvent {

    public AbstractForgeNetworkManager() {
        super(() -> null);
    }

    public static void register(ResourceLocation channelName, String channelVersion, Object dispatcher) {
        EventNetworkChannel channel = NetworkRegistry.ChannelBuilder
                .named(channelName)
                .networkProtocolVersion(() -> channelVersion)
                .clientAcceptedVersions(sv -> true)
                .serverAcceptedVersions(cv -> {
                    if (ModConfig.Common.enableProtocolCheck) {
                        return cv.equals(channelVersion);
                    }
                    return true;
                })
                .eventNetworkChannel();
        channel.registerObject(dispatcher);
    }

    public static PacketDistributor.PacketTarget server() {
        return PacketDistributor.SERVER.noArg();
    }

    public static PacketDistributor.PacketTarget allPlayers() {
        return PacketDistributor.ALL.noArg();
    }

    public static PacketDistributor.PacketTarget trackingEntityAndSelf(Supplier<Entity> supplier) {
        return PacketDistributor.TRACKING_ENTITY_AND_SELF.with(supplier);
    }

    public enum Direction {
        PLAY_TO_SERVER(NetworkDirection.PLAY_TO_SERVER), PLAY_TO_CLIENT(NetworkDirection.PLAY_TO_CLIENT);

        private final NetworkDirection networkDirection;

        Direction(NetworkDirection networkDirection) {
            this.networkDirection = networkDirection;
        }

        public <T extends Packet<?>> ICustomPacket<T> buildPacket(Pair<FriendlyByteBuf, Integer> packetData, ResourceLocation channelName) {
            return networkDirection.buildPacket(packetData, channelName);
        }
    }
}
