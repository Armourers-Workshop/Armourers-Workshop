package moe.plushie.armourers_workshop.compatibility.client.gui;

import com.apple.library.coregraphics.CGGradient;
import com.apple.library.coregraphics.CGGraphicsContext;
import com.apple.library.coregraphics.CGGraphicsRenderer;
import com.apple.library.coregraphics.CGGraphicsState;
import com.apple.library.coregraphics.CGRect;
import com.apple.library.foundation.NSString;
import com.apple.library.uikit.UIFont;
import com.mojang.blaze3d.vertex.PoseStack;
import com.mojang.blaze3d.vertex.Tesselator;
import moe.plushie.armourers_workshop.api.annotation.Available;
import moe.plushie.armourers_workshop.utils.ObjectUtils;
import moe.plushie.armourers_workshop.utils.RenderSystem;
import net.fabricmc.api.EnvType;
import net.fabricmc.api.Environment;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Font;
import net.minecraft.client.gui.screens.Screen;
import net.minecraft.client.gui.screens.inventory.InventoryScreen;
import net.minecraft.client.renderer.MultiBufferSource;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.util.FormattedCharSequence;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.item.ItemStack;
import org.jetbrains.annotations.Nullable;

import java.util.List;

@Available("[1.16, 1.18)")
@Environment(EnvType.CLIENT)
public class AbstractGraphicsRenderer implements CGGraphicsRenderer, CGGraphicsState {

    private final PoseStack poseStack;
    private final int mouseX;
    private final int mouseY;
    private final float partialTicks;

    private final AbstractMenuScreenImpl<?> screen;
    private final Font font;
    private UIFont uifont;

    public AbstractGraphicsRenderer(AbstractMenuScreenImpl<?> screen, Font font, PoseStack poseStack, int mouseX, int mouseY, float partialTicks) {
        this.screen = screen;
        this.font = font;
        this.poseStack = poseStack;
        this.mouseX = mouseX;
        this.mouseY = mouseY;
        this.partialTicks = partialTicks;
    }

    public static PoseStack of(CGGraphicsContext context) {
        AbstractGraphicsRenderer impl = ObjectUtils.unsafeCast(context.state());
        return impl.poseStack;
    }

    public static CGGraphicsContext of(AbstractMenuScreenImpl<?> screen, Font font, PoseStack poseStack, int mouseX, int mouseY, float partialTicks) {
        AbstractGraphicsRenderer impl = new AbstractGraphicsRenderer(screen, font, poseStack, mouseX, mouseY, partialTicks);
        return new CGGraphicsContext(impl, impl);
    }

    public void renderText(FormattedCharSequence text, float x, float y, int textColor, boolean shadow, boolean bl2, int j, int k, UIFont font, CGGraphicsContext context) {
        if (font == null) {
            font = context.state().font();
        }
        MultiBufferSource.BufferSource bufferSource = MultiBufferSource.immediate(Tesselator.getInstance().getBuilder());
        font.font().drawInBatch(text, x, y, textColor, shadow, poseStack.last().pose(), bufferSource, bl2, j, k);
        bufferSource.endBatch();
    }

    @Override
    public void renderTooltip(NSString text, CGRect rect, @Nullable UIFont font, CGGraphicsContext context) {
        if (font == null) {
            font = context.state().font();
        }
        // there are some versions of tooltip that don't split normally,
        // and while we can't decide on the final tooltip size,
        // but we can to handle the break the newline
        List<? extends FormattedCharSequence> texts = font.font().split(text.component(), 100000);
        screen._renderTooltip(poseStack, texts, mouseX, mouseY);
    }

    @Override
    public void renderImage(ResourceLocation texture, int x, int y, int u, int v, int width, int height, int texWidth, int texHeight, CGGraphicsContext context) {
        RenderSystem.setShaderTexture(0, texture);
        Screen.blit(poseStack, x, y, 0, u, v, width, height, texWidth, texHeight);
    }

    @Override
    public void renderColor(int x1, int y1, int x2, int y2, int color, CGGraphicsContext context) {
        Screen.fill(poseStack, x1, y1, x2, y2, color);
    }

    @Override
    public void renderGradient(CGGradient gradient, CGRect rect, CGGraphicsContext context) {
        int i = rect.x;
        int j = rect.y;
        int k = rect.getMaxX();
        int l = rect.getMaxY();
        int m = gradient.startColor.getRGB();
        int n = gradient.endColor.getRGB();
        screen._fillGradient(AbstractGraphicsRenderer.of(context), i, j, k, l, m, n);
    }

    @Override
    public void renderEntity(LivingEntity entity, int x, int y, int scale, float mouseX, float mouseY, CGGraphicsContext context) {
        RenderSystem.pushMatrix();
        RenderSystem.multMatrix(poseStack.last().pose());
        InventoryScreen.renderEntityInInventory(x, y, scale, mouseX, mouseY, entity);
        RenderSystem.popMatrix();
    }

    @Override
    public void renderItem(ItemStack itemStack, int x, int y, CGGraphicsContext context) {
        Minecraft.getInstance().getItemRenderer().renderAndDecorateFakeItem(itemStack, x, y);
    }

    @Override
    public UIFont font() {
        if (uifont == null) {
            uifont = new UIFont(font);
        }
        return uifont;
    }

    @Override
    public int mouseX() {
        return mouseX;
    }

    @Override
    public int mouseY() {
        return mouseY;
    }

    @Override
    public float partialTicks() {
        return partialTicks;
    }

    @Override
    public PoseStack ctm() {
        return poseStack;
    }
}
